<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LLM Inference Cost Calculator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap');
  :root {
    --bg:#0a0e14;--panel:#111820;--border:#1e2a3a;--border-hi:#2d4a6a;
    --text:#c5cdd8;--text-dim:#5a6a7a;--text-bright:#e8edf3;
    --accent:#ff6b35;--accent2:#4ecdc4;--green:#2ecc71;--red:#e74c3c;
    --blue:#3498db;--yellow:#f1c40f;--purple:#9b59b6;
    --mono:'JetBrains Mono',monospace;--sans:'IBM Plex Sans',sans-serif;
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{font-family:var(--sans);background:var(--bg);color:var(--text);line-height:1.6;min-height:100vh}
  .container{max-width:1200px;margin:0 auto;padding:24px 20px}

  .topbar{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:20px;padding:10px 16px;background:var(--panel);border:1px solid var(--border);border-radius:8px;font-size:0.82em}
  .topbar a{color:var(--accent2);text-decoration:none;font-weight:600}
  .topbar a:hover{text-decoration:underline}
  .lang-btns{display:flex;gap:4px}
  .lang-btn{background:var(--border);border:1px solid transparent;border-radius:5px;padding:4px 10px;color:var(--text-dim);font-family:var(--mono);font-size:0.82em;font-weight:600;cursor:pointer;transition:all .15s}
  .lang-btn.active{background:rgba(255,107,53,.15);border-color:var(--accent);color:var(--accent)}
  .lang-btn:hover:not(.active){background:var(--border-hi);color:var(--text)}

  header{margin-bottom:32px;border-bottom:1px solid var(--border);padding-bottom:16px}
  header h1{font-family:var(--mono);font-size:1.4em;font-weight:700;color:var(--accent);letter-spacing:-.5px}
  header p{color:var(--text-dim);font-size:.82em;margin-top:4px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:20px}
  @media(max-width:800px){.grid{grid-template-columns:1fr}.ref-grid{grid-template-columns:1fr!important}}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:18px}
  .panel-title{font-family:var(--mono);font-size:.72em;font-weight:700;text-transform:uppercase;letter-spacing:1.5px;color:var(--text-dim);margin-bottom:14px;display:flex;align-items:center;gap:8px}
  .panel-title .dot{width:6px;height:6px;border-radius:50%;display:inline-block}
  .control{margin-bottom:14px}.control:last-child{margin-bottom:0}
  .control label{display:flex;justify-content:space-between;align-items:baseline;font-size:.82em;color:var(--text);margin-bottom:5px;font-weight:500}
  .control label .val{font-family:var(--mono);font-weight:700;color:var(--accent);font-size:.95em}
  input[type="range"]{-webkit-appearance:none;width:100%;height:6px;border-radius:3px;background:var(--border);outline:none}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid var(--bg);box-shadow:0 0 8px rgba(255,107,53,.4)}
  input[type="range"]::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer;border:2px solid var(--bg)}
  .range-wrap{position:relative;padding-bottom:22px}
  .range-marks{position:relative;width:100%;height:20px;margin-top:3px;font-size:.6em;color:var(--text-dim);font-family:var(--mono)}
  .range-marks .mark{position:absolute;white-space:nowrap;text-align:center;line-height:1.25}
  .toggle-row{display:flex;align-items:center;gap:10px;margin-bottom:10px}
  .toggle{position:relative;width:40px;height:22px;cursor:pointer}
  .toggle input{opacity:0;width:0;height:0}
  .toggle .slider{position:absolute;inset:0;background:var(--border);border-radius:22px;transition:.2s}
  .toggle .slider:before{content:'';position:absolute;width:16px;height:16px;left:3px;bottom:3px;background:var(--text-dim);border-radius:50%;transition:.2s}
  .toggle input:checked+.slider{background:var(--accent)}
  .toggle input:checked+.slider:before{transform:translateX(18px);background:#fff}
  .toggle-label{font-size:.82em;font-weight:500}
  .quant-btns,.gpu-btns{display:flex;gap:6px}
  .quant-btn{flex:1;padding:6px 8px;background:var(--border);border:1px solid transparent;border-radius:5px;color:var(--text-dim);font-family:var(--mono);font-size:.78em;font-weight:600;cursor:pointer;text-align:center;transition:all .15s}
  .quant-btn.active{background:rgba(255,107,53,.15);border-color:var(--accent);color:var(--accent)}
  .quant-btn:hover:not(.active){background:var(--border-hi);color:var(--text)}
  .gpu-btn{flex:1;padding:5px;background:var(--border);border:1px solid transparent;border-radius:5px;color:var(--text-dim);font-family:var(--mono);font-size:.75em;font-weight:600;cursor:pointer;text-align:center;transition:all .15s}
  .gpu-btn.active{background:rgba(78,205,196,.12);border-color:var(--accent2);color:var(--accent2)}
  .gpu-btn.recommended{box-shadow:0 0 0 1px var(--yellow)}
  .gpu-btn.too-small{opacity:.35;text-decoration:line-through;cursor:not-allowed}
  .formula-block{background:rgba(0,0,0,.3);border:1px solid var(--border);border-left:3px solid var(--accent2);border-radius:4px;padding:12px 14px;margin:10px 0;font-family:var(--mono);font-size:.76em;line-height:1.8;color:var(--text);white-space:pre-wrap;overflow-x:auto}
  .formula-block .comment{color:var(--text-dim)}.formula-block .result{color:var(--accent);font-weight:700}
  .formula-block .highlight{color:var(--accent2);font-weight:600}.formula-block .warn{color:var(--yellow)}
  .results-section{margin-top:8px}
  .result-step{background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:16px 18px;margin-bottom:12px}
  .step-header{display:flex;align-items:center;gap:10px;margin-bottom:8px}
  .step-num{font-family:var(--mono);font-weight:800;font-size:.7em;width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;flex-shrink:0}
  .step-title{font-weight:600;font-size:.9em;color:var(--text-bright)}
  .verdict-box{background:linear-gradient(135deg,#0a1a0a,#111820);border:2px solid var(--green);border-radius:10px;padding:24px;margin-top:16px;text-align:center}
  .verdict-box.loss{background:linear-gradient(135deg,#1a0a0a,#111820);border-color:var(--red)}
  .verdict-number{font-family:var(--mono);font-size:2.4em;font-weight:800;line-height:1;margin:8px 0 4px}
  .verdict-label{font-size:.82em;color:var(--text-dim)}
  .verdict-sub{font-family:var(--mono);font-size:1em;margin-top:8px;font-weight:600}
  .mini-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-top:14px}
  .mini-card{background:rgba(0,0,0,.25);border:1px solid var(--border);border-radius:6px;padding:12px;text-align:center}
  .mini-card .mc-val{font-family:var(--mono);font-size:1.2em;font-weight:700;color:var(--accent2)}
  .mini-card .mc-label{font-size:.7em;color:var(--text-dim);margin-top:2px}
  .note-text{font-size:.72em;color:var(--text-dim);margin-top:6px;font-style:italic}
  .full-width{grid-column:1/-1}
  .input-small{width:90px;background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:4px 8px;color:var(--accent);font-family:var(--mono);font-size:.82em;font-weight:600;text-align:right}
  .input-small:focus{outline:none;border-color:var(--accent)}
  .rc{background:rgba(0,0,0,.2);border:1px solid var(--border);border-radius:5px;padding:10px}
  .rc-t{font-family:var(--mono);font-weight:700;margin-bottom:4px}
  .rc-b{color:var(--text-dim);line-height:1.7}
</style>
</head>
<body>
<div class="container">

<!-- Credit + language toggle -->
<div class="topbar">
  <span>Made by <a href="https://t.me/mlphys" target="_blank">@freQuensy23</a> · channel <a href="https://t.me/mlphys" target="_blank">t.me/mlphys</a></span>
  <div class="lang-btns">
    <button class="lang-btn active" onclick="setLang('en')">EN</button>
    <button class="lang-btn" onclick="setLang('ru')">RU</button>
  </div>
</div>

<header>
  <h1>⚡ LLM Inference Cost Calculator</h1>
  <p id="h-sub"></p>
</header>

<div class="grid">
  <!-- MODEL -->
  <div class="panel">
    <div class="panel-title"><span class="dot" style="background:var(--accent)"></span><span id="l-model"></span></div>
    <div class="control">
      <label><span id="l-params"></span> <span class="val" id="v-params"></span></label>
      <div class="range-wrap">
        <input type="range" id="s-params" min="7" max="1800" value="700" step="1" oninput="update()">
        <div class="range-marks" id="marks-params"></div>
      </div>
    </div>
    <div class="toggle-row">
      <label class="toggle"><input type="checkbox" id="t-moe" checked onchange="update()"><span class="slider"></span></label>
      <span class="toggle-label">Mixture-of-Experts (MoE)</span>
    </div>
    <div class="control" id="active-control">
      <label><span id="l-active"></span> <span class="val" id="v-active"></span></label>
      <div class="range-wrap">
        <input type="range" id="s-active" min="1" max="500" value="30" step="1" oninput="update()">
        <div class="range-marks" id="marks-active"></div>
      </div>
    </div>
    <div class="control">
      <label id="l-quant"></label>
      <div class="quant-btns">
        <button class="quant-btn" data-q="16" onclick="setQuant(16)">FP16<br><span style="font-size:.8em;opacity:.6">2 B/p</span></button>
        <button class="quant-btn active" data-q="8" onclick="setQuant(8)">FP8<br><span style="font-size:.8em;opacity:.6">1 B/p</span></button>
        <button class="quant-btn" data-q="4" onclick="setQuant(4)">FP4<br><span style="font-size:.8em;opacity:.6">0.5 B/p</span></button>
      </div>
    </div>
    <div class="control">
      <label id="l-gpunode"></label>
      <div class="gpu-btns" id="gpu-btns">
        <button class="gpu-btn" data-g="1" onclick="setGpus(1)">1×</button>
        <button class="gpu-btn" data-g="2" onclick="setGpus(2)">2×</button>
        <button class="gpu-btn" data-g="4" onclick="setGpus(4)">4×</button>
        <button class="gpu-btn" data-g="8" onclick="setGpus(8)">8×</button>
        <button class="gpu-btn" data-g="16" onclick="setGpus(16)">16×</button>
      </div>
      <p class="note-text" id="gpu-note"></p>
    </div>
  </div>

  <!-- INFRA -->
  <div class="panel">
    <div class="panel-title"><span class="dot" style="background:var(--accent2)"></span><span id="l-infra"></span></div>
    <div class="control">
      <label><span id="l-gpuprice"></span> <span class="val" id="v-gpuprice"></span></label>
      <div class="range-wrap">
        <input type="range" id="s-gpuprice" min="2" max="7" value="4" step="0.1" oninput="update()">
        <div class="range-marks" id="marks-gpuprice"></div>
      </div>
    </div>
    <div class="control">
      <label><span id="l-ctx"></span> <span class="val" id="v-ctx"></span></label>
      <div class="range-wrap">
        <input type="range" id="s-ctx" min="512" max="200000" value="70000" step="512" oninput="update()">
        <div class="range-marks" id="marks-ctx"></div>
      </div>
    </div>
    <div class="control">
      <label><span id="l-util"></span> <span class="val" id="v-util"></span></label>
      <div class="range-wrap">
        <input type="range" id="s-util" min="20" max="100" value="90" step="5" oninput="update()">
        <div class="range-marks" id="marks-util"></div>
      </div>
    </div>
    <div class="control">
      <label><span id="l-eff"></span> <span class="val" id="v-eff"></span></label>
      <div class="range-wrap">
        <input type="range" id="s-eff" min="30" max="90" value="65" step="5" oninput="update()">
        <div class="range-marks" id="marks-eff"></div>
      </div>
    </div>
    <div class="control">
      <label>Prompt cache hit rate <span class="val" id="v-cache"></span></label>
      <div class="range-wrap">
        <input type="range" id="s-cache" min="0" max="95" value="70" step="5" oninput="update()">
        <div class="range-marks" id="marks-cache"></div>
      </div>
    </div>
  </div>

  <!-- SUBSCRIPTION -->
  <div class="panel full-width">
    <div class="panel-title"><span class="dot" style="background:var(--yellow)"></span><span id="l-sub"></span></div>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:14px;">
      <div class="control"><label><span id="l-outtok"></span> <input class="input-small" id="i-outtok" type="number" value="100" min="0.1" max="500" step="0.1" oninput="update()"></label></div>
      <div class="control"><label><span id="l-intok"></span> <input class="input-small" id="i-intok" type="number" value="500" min="0.1" max="2000" step="0.1" oninput="update()"></label></div>
      <div class="control"><label><span id="l-price"></span> <input class="input-small" id="i-price" type="number" value="200" min="1" max="2000" step="1" oninput="update()"></label></div>
    </div>
  </div>
</div>

<div class="results-section" id="results"></div>
</div>

<script>
/* ── state ── */
let lang='en', quantBits=8, numGpus=8, gpuManual=false;
const B200={vram_gb:192,bw_bytes:8e12,flops:{16:2250e12,8:4500e12,4:9000e12}};
const $=id=>document.getElementById(id);
const fmt=(n,d=1)=>{if(n>=1e12)return(n/1e12).toFixed(d)+'T';if(n>=1e9)return(n/1e9).toFixed(d)+'B';if(n>=1e6)return(n/1e6).toFixed(d)+'M';if(n>=1e3)return(n/1e3).toFixed(d)+'k';return n.toFixed(d)};
const fmtN=n=>n.toLocaleString('en-US');
const fmtD=(n,d=2)=>'$'+n.toFixed(d);

/* ── i18n ── */
const I={
en:{
  sub:'Inference physics: from GPU bandwidth to per-token cost. Roofline model, no magic numbers.',
  model:'Model',params:'Total parameters',active:'Active parameters',quant:'Quantization',
  gpunode:'GPU node (B200 × N)',infra:'Infrastructure',gpuprice:'GPU price',ctx:'Avg context length',
  util:'GPU utilization',eff:'Compute efficiency',subPanel:'Subscription (per user / month)',
  outtok:'Output tokens (M)',intok:'Input tokens (M)',price:'Subscription ($)',
  mDI:'$2.5 DeepInfra',mExp:'$3.5 retail',mHyp:'$7 hyper',
  mNaive:'30% naive',mProd:'65% prod',mIdeal:'90% ideal',
  mNoCache:'0% none',mTypCache:'70% typical',mMaxCache:'95% max',
  gpuNote:(w,m,f)=>`Weights: ${w} GB. Min ${m}× B200 (80% VRAM). ${f?'':'⚠️ Does not fit!'}`,
  s1:'GPU Memory',s2:'KV-cache → batch size',s3:'Throughput',s4:'Token cost',s5:'Financials (per user / month)',
  sRef:'Where the numbers come from',
  cWeight:'// Model weights',cVram:'// Cluster VRAM',cKv:'// KV-cache budget',
  cArch:'// Architecture (from',cKvTok:'// KV per token (FP8 KV cache)',cKvUser:'// KV per user (ctx',
  cCluster:'// Cluster',cDecode:'// Decode (autoregressive, 1 tok/user/step)',
  cCross:'// crossover batch/GPU =',cActBatch:'// actual batch',cPrefill:'// Prefill (mat×mat → compute-bound)',
  cGpu:'// GPU cost',cTokHr:'// Tokens/hr (× util',cCache:'cache',
  verdict:'VERDICT',margin:'margin',cost:'cost',profit:'profit',loss:'loss',
  rB200:'192 GB HBM3e, 8 TB/s bandwidth, 4500 TFLOPS FP8 dense.<br><span style="color:var(--text)">Source:</span> NVIDIA datasheet + InferenceMAX v1 benchmarks.',
  rGpuT:'GPU price ($2–$7)',
  rGpu:'<a href="https://deepinfra.com/pricing" target="_blank" style="color:var(--accent2)">DeepInfra B200 — $2.5/hr</a>. $3–4 — retail (Lambda, DataCrunch). $5–7 — AWS/GCP on-demand.',
  rWtT:'weight = params × bytes_per_param',
  rWt:'FP8 = 1 byte/param. 700B model = 700 GB weights.<br>MoE: <b>all</b> experts in VRAM (full size), but compute only on active.',
  rKvT:'KV-cache → batch',
  rKv:'kv/tok = 2(K,V) × layers × (hidden/GQA) × 1B.<br>max_batch = free VRAM / (kv/tok × context).',
  rDecT:'Decode throughput (roofline)',
  rDec:cb=>`bw_tput = batch × bandwidth / active_weights — memory allows.<br>comp_tput = FLOPS / (2 × active_params) — compute allows.<br>Decode = min(bw, comp) × efficiency. Batch &lt; ${cb}/GPU → bandwidth-bound, above → compute-bound.`,
  rPfT:'Prefill throughput',
  rPf:'Prefill = compute-bound (mat×mat, not mat×vec like decode).<br>prefill_tput = comp_tput × efficiency.<br>Input tokens are 10–50× cheaper than output.',
  rEffT:'Efficiency',
  rEff:v=>`Ratio of real throughput to theoretical peak.<br>Includes: TP all-reduce overhead, CUDA launch latency, memory access patterns, framework scheduling.<br>30% — naive impl. 65% — vLLM/TRT-LLM prod. 85%+ — single-GPU ideal.`,
  rUtilT:'Utilization',
  rUtil:v=>`Fraction of time GPU generates tokens vs idle.<br>Includes: load peaks/valleys (day/night), cold start, batch padding.<br>40–60% — small deploy. 80–90% — large provider with global load.`,
  rCaT:'Prompt cache hit',
  rCa:v=>`Share of input tokens with KV-cache already computed (system prompt, repeated context).<br>Cached tokens skip prefill — memory read only, ~10% of compute cost.<br>Formula: effective_input_cost = raw_cost × (1 − hit_rate × 0.9).<br>70% — typical for chat with long system prompt. 0% — every request from scratch.`,
  rTokT:'Output / Input tokens',
  rTok:'Default: 7.3M out / 17.3M in — estimate for Max 20x power user.<br>Base: ~220k tok/5hr window × 66 windows/mo × 1.7 upward correction.<br><span style="color:var(--yellow)">⚠ Anthropic does not publish exact limits.</span> Community measurements (Faros AI, Reddit). Uncertainty ±50%.',
  rFmT:'$/MTok → $/mo',
  rFm:'cost_out = gpu_cost_hr / (decode_tok_hr / 1M)<br>cost_in = gpu_cost_hr / (prefill_tok_hr / 1M)<br>monthly = out_M × cost_out + in_M × cost_in<br>margin = (subscription − monthly) / subscription',
},
ru:{
  sub:'Физика инференса: от GPU bandwidth до себестоимости токена. Roofline model, не магические числа.',
  model:'Модель',params:'Всего параметров',active:'Активных параметров',quant:'Квантизация',
  gpunode:'GPU нода (B200 × N)',infra:'Инфраструктура',gpuprice:'Цена GPU',ctx:'Средний контекст',
  util:'Утилизация GPU',eff:'Эффективность вычислений',subPanel:'Подписка (месяц на юзера)',
  outtok:'Output токенов (M)',intok:'Input токенов (M)',price:'Цена подписки ($)',
  mDI:'$2.5 DeepInfra',mExp:'$3.5 розн.',mHyp:'$7 hyper',
  mNaive:'30% наивно',mProd:'65% prod',mIdeal:'90% идеал',
  mNoCache:'0% нет',mTypCache:'70% типично',mMaxCache:'95% макс',
  gpuNote:(w,m,f)=>`Веса: ${w} GB. Мин: ${m}× B200 (80% VRAM). ${f?'':'⚠️ Не помещается!'}`,
  s1:'Память GPU',s2:'KV-cache → batch size',s3:'Throughput',s4:'Стоимость токена',s5:'Финмодель (месяц / юзер)',
  sRef:'Откуда взялись числа',
  cWeight:'// Вес модели',cVram:'// VRAM кластера',cKv:'// Под KV-cache',
  cArch:'// Архитектура (из',cKvTok:'// KV на токен (FP8 KV cache)',cKvUser:'// KV на юзера (ctx',
  cCluster:'// Кластер',cDecode:'// Decode (авторегрессия, 1 tok/user/step)',
  cCross:'// crossover batch/GPU =',cActBatch:'// actual batch',cPrefill:'// Prefill (mat×mat → compute-bound)',
  cGpu:'// GPU',cTokHr:'// Токенов/час (× util',cCache:'cache',
  verdict:'ВЕРДИКТ',margin:'маржа',cost:'себестоимость',profit:'прибыль',loss:'убыток',
  rB200:'192 GB HBM3e, 8 TB/s bandwidth, 4500 TFLOPS FP8 dense.<br><span style="color:var(--text)">Источник:</span> NVIDIA datasheet + InferenceMAX v1 бенчмарки.',
  rGpuT:'Цена GPU ($2–$7)',
  rGpu:'<a href="https://deepinfra.com/pricing" target="_blank" style="color:var(--accent2)">DeepInfra B200 — $2.5/ч</a>. $3–4 — розница (Lambda, DataCrunch). $5–7 — AWS/GCP on-demand.',
  rWtT:'weight = params × bytes_per_param',
  rWt:'FP8 = 1 байт/параметр. 700B модель = 700 GB весов.<br>MoE: <b>все</b> эксперты в VRAM (полный размер), но compute только на active.',
  rKvT:'KV-cache → batch',
  rKv:'kv/tok = 2(K,V) × layers × (hidden/GQA) × 1B.<br>max_batch = свободная VRAM / (kv/tok × контекст).',
  rDecT:'Decode throughput (roofline)',
  rDec:cb=>`bw_tput = batch × bandwidth / active_weights — сколько позволяет память.<br>comp_tput = FLOPS / (2 × active_params) — сколько позволяет compute.<br>Decode = min(bw, comp) × efficiency. При batch &lt; ${cb}/GPU — bandwidth-bound, выше — compute-bound.`,
  rPfT:'Prefill throughput',
  rPf:'Prefill = compute-bound (mat×mat, не mat×vec как decode).<br>prefill_tput = comp_tput × efficiency.<br>Поэтому input токены в 10–50× дешевле output.',
  rEffT:'Эффективность',
  rEff:v=>`Отношение реального throughput к теоретическому пику.<br>Включает: TP all-reduce overhead, CUDA launch latency, memory access patterns, framework scheduling.<br>30% — наивная имплементация. 65% — vLLM/TRT-LLM prod. 85%+ — single-GPU идеал.`,
  rUtilT:'Утилизация',
  rUtil:v=>`Доля времени, когда GPU реально генерирует токены, а не простаивает.<br>Включает: пики/спады нагрузки (день/ночь), cold start, batch padding.<br>40–60% — малый деплой. 80–90% — крупный provider с глобальной нагрузкой.`,
  rCaT:'Prompt cache hit',
  rCa:v=>`Доля input токенов, для которых KV-cache уже вычислен (system prompt, повторный контекст).<br>Cached tokens пропускают prefill — только чтение из памяти, ~10% стоимости compute.<br>Формула: effective_input_cost = raw_cost × (1 − hit_rate × 0.9).<br>70% — типично для чата с длинным system prompt. 0% — каждый запрос с нуля.`,
  rTokT:'Output/Input токены',
  rTok:'Дефолт: 7.3M out / 17.3M in — оценка для power user Max 20x.<br>Базовая цифра: ~220k tok/5ч окно × 66 окон/мес × 1.7 коррекция вверх.<br><span style="color:var(--yellow)">⚠ Anthropic не публикует точные лимиты.</span> Данные из замеров сообщества (Faros AI, Reddit). Неопределённость ±50%.',
  rFmT:'$/MTok → $/мес',
  rFm:'cost_out = gpu_cost_hr / (decode_tok_hr / 1M)<br>cost_in = gpu_cost_hr / (prefill_tok_hr / 1M)<br>monthly = out_M × cost_out + in_M × cost_in<br>margin = (подписка − monthly) / подписка',
}};
const t=k=>I[lang][k]||I.en[k]||k;

/* ── language switch ── */
function setLang(l){
  lang=l;
  document.querySelectorAll('.lang-btn').forEach(b=>b.classList.toggle('active',b.textContent.trim()===l.toUpperCase()));
  applyLabels(); initMarks(); update();
}
function applyLabels(){
  $('h-sub').textContent=t('sub');
  $('l-model').textContent=t('model');
  $('l-params').textContent=t('params');
  $('l-active').textContent=t('active');
  $('l-quant').textContent=t('quant');
  $('l-gpunode').textContent=t('gpunode');
  $('l-infra').textContent=t('infra');
  $('l-gpuprice').textContent=t('gpuprice');
  $('l-ctx').textContent=t('ctx');
  $('l-util').textContent=t('util');
  $('l-eff').textContent=t('eff');
  $('l-sub').textContent=t('subPanel');
  $('l-outtok').textContent=t('outtok');
  $('l-intok').textContent=t('intok');
  $('l-price').textContent=t('price');
}

/* ── slider marks ── */
function markPct(v,mn,mx){return((v-mn)/(mx-mn))*100}
function renderMarks(id,mn,mx,marks){
  const el=$(id);el.innerHTML='';
  marks.forEach(m=>{const s=document.createElement('span');s.className='mark';s.innerHTML=m.label;
    const p=markPct(m.val,mn,mx);s.style.left=p+'%';
    if(p<=1)s.style.transform='translateX(0)';else if(p>=99)s.style.transform='translateX(-100%)';
    else s.style.transform='translateX(-50%)';el.appendChild(s)});
}
function initMarks(){
  renderMarks('marks-params',7,1800,[{val:7,label:'7B'},{val:70,label:'70B'},{val:405,label:'405B'},{val:700,label:'700B'},{val:1800,label:'1.8T'}]);
  renderMarks('marks-active',1,500,[{val:1,label:'1B'},{val:37,label:'37B DS-R1'},{val:150,label:'150B'},{val:500,label:'500B'}]);
  renderMarks('marks-gpuprice',2,7,[{val:2.5,label:t('mDI')},{val:4,label:t('mExp')},{val:5,label:'$5'},{val:7,label:t('mHyp')}]);
  renderMarks('marks-ctx',512,200000,[{val:512,label:'512'},{val:4096,label:'4k'},{val:16384,label:'16k'},{val:70000,label:'70k'},{val:200000,label:'200k'}]);
  renderMarks('marks-util',20,100,[{val:20,label:'20%'},{val:50,label:'50%'},{val:70,label:'70%'},{val:90,label:'90%'},{val:100,label:'100%'}]);
  renderMarks('marks-eff',30,90,[{val:30,label:t('mNaive')},{val:65,label:t('mProd')},{val:90,label:t('mIdeal')}]);
  renderMarks('marks-cache',0,95,[{val:0,label:t('mNoCache')},{val:40,label:'40%'},{val:70,label:t('mTypCache')},{val:95,label:t('mMaxCache')}]);
}

/* ── controls ── */
function setQuant(q){quantBits=q;document.querySelectorAll('.quant-btn').forEach(b=>b.classList.toggle('active',+b.dataset.q===q));gpuManual=false;update()}
function setGpus(g){numGpus=g;gpuManual=true;update()}

/* ── compute ── */
function estimateArch(totalB,activeB,isMoE){
  const ref=isMoE?activeB:totalB;
  let nL=Math.round(Math.pow(ref*1e9/196608,1/3));
  nL=Math.max(12,Math.min(256,nL));
  const hD=Math.round(Math.sqrt(ref*1e9/(12*nL)));
  return{nLayers:nL,hiddenDim:hD};
}

function compute(){
  const totalB=+$('s-params').value, isMoE=$('t-moe').checked;
  const activeB=isMoE?Math.min(+$('s-active').value,totalB):totalB;
  const bpp=quantBits===16?2:quantBits===8?1:0.5;
  const avgCtx=+$('s-ctx').value,util=+$('s-util').value/100,eff=+$('s-eff').value/100;
  const cacheHit=+$('s-cache').value/100,gpuPrice=+$('s-gpuprice').value;
  const outTokM=+$('i-outtok').value||100,inTokM=+$('i-intok').value||500,subPrice=+$('i-price').value||200;

  const weightGB=totalB*bpp,usable=B200.vram_gb*0.80;
  const minGpus=Math.max(1,Math.ceil(weightGB/usable));
  if(!gpuManual)numGpus=[1,2,4,8,16].find(g=>g>=minGpus)||16;

  const totalVram=numGpus*B200.vram_gb,kvBudgetGB=totalVram*0.80-weightGB,fits=kvBudgetGB>0;
  const arch=estimateArch(totalB,activeB,isMoE);
  const gqa=totalB>100?4:(totalB>30?2:1);
  const kvBpT=2*arch.nLayers*(arch.hiddenDim/gqa)*1,kvPerUser=kvBpT*avgCtx;
  const maxBatch=fits?Math.max(1,Math.floor(kvBudgetGB*1e9/kvPerUser)):0;

  const activeBytes=activeB*1e9*bpp,totalBW=numGpus*B200.bw_bytes,totalFLOPS=numGpus*B200.flops[quantBits];
  const bwTput=maxBatch*totalBW/activeBytes,compTput=totalFLOPS/(2*activeB*1e9);
  const crossBatch=Math.round(B200.flops[quantBits]*bpp/(2*B200.bw_bytes));

  const rawDec=Math.min(bwTput,compTput),decTput=rawDec*eff,pfTput=compTput*eff;
  const perUser=maxBatch>0?decTput/maxBatch:0;

  const gpuCostHr=numGpus*gpuPrice;
  const decHr=decTput*3600*util,pfHr=pfTput*3600*util;
  const cOut=decHr>0?gpuCostHr/(decHr/1e6):Infinity;
  const cInRaw=pfHr>0?gpuCostHr/(pfHr/1e6):Infinity;
  const cIn=cInRaw*(1-cacheHit*0.9);

  const mOut=outTokM*cOut,mIn=inTokM*cIn,mTotal=mOut+mIn;
  const profit=subPrice-mTotal,margin=subPrice>0?profit/subPrice*100:0;

  return{totalB,activeB,isMoE,bpp,quantBits,weightGB,minGpus,numGpus,totalVram,kvBudgetGB,fits,
    arch,gqa,kvBpT,kvPerUser,maxBatch,avgCtx,totalBW,totalFLOPS,activeBytes,
    bwTput,compTput,crossBatch,rawDec,decTput,pfTput,perUser,
    gpuPrice,gpuCostHr,util,eff,cacheHit,decHr,pfHr,cOut,cIn,cInRaw,
    outTokM,inTokM,subPrice,mOut,mIn,mTotal,profit,margin};
}

/* ── render ── */
function render(d){
  $('v-params').textContent=d.totalB+'B';
  $('v-active').textContent=d.activeB+'B';
  $('v-gpuprice').textContent='$'+d.gpuPrice.toFixed(2)+'/h';
  $('v-ctx').textContent=fmtN(d.avgCtx)+' tok';
  $('v-util').textContent=Math.round(d.util*100)+'%';
  $('v-eff').textContent=Math.round(d.eff*100)+'%';
  $('v-cache').textContent=Math.round(d.cacheHit*100)+'%';
  $('active-control').style.display=d.isMoE?'block':'none';

  document.querySelectorAll('.gpu-btn').forEach(b=>{
    const g=+b.dataset.g;
    b.classList.toggle('active',g===d.numGpus);
    b.classList.toggle('too-small',g<d.minGpus);
    b.classList.toggle('recommended',g===d.minGpus&&g!==d.numGpus);
  });
  $('gpu-note').textContent=t('gpuNote')(d.weightGB.toFixed(0),d.minGpus,d.fits);

  const isBW=d.bwTput<d.compTput,bL=isBW?'BANDWIDTH-BOUND':'COMPUTE-BOUND',bC=isBW?'var(--blue)':'var(--purple)';
  const pOrL=d.profit>=0;
  const rc=(color,title,body)=>`<div class="rc"><div class="rc-t" style="color:${color}">${title}</div><div class="rc-b">${body}</div></div>`;

  $('results').innerHTML=`
    <div class="result-step">
      <div class="step-header"><div class="step-num" style="background:var(--accent);color:var(--bg)">1</div><div class="step-title">${t('s1')}</div></div>
      <div class="formula-block"><span class="comment">${t('cWeight')}</span>
weight = ${d.totalB}B × ${d.bpp} B/p = <span class="result">${d.weightGB.toFixed(0)} GB</span>

<span class="comment">${t('cVram')}</span>
vram   = ${d.numGpus} × 192 GB = ${d.totalVram} GB  (usable 80% = ${(d.totalVram*.8).toFixed(0)} GB)

<span class="comment">${t('cKv')}</span>
kv_budget = ${(d.totalVram*.8).toFixed(0)} − ${d.weightGB.toFixed(0)} = <span class="${d.kvBudgetGB>0?'result':'warn'}">${d.kvBudgetGB.toFixed(0)} GB</span></div>
    </div>

    <div class="result-step">
      <div class="step-header"><div class="step-num" style="background:var(--accent2);color:var(--bg)">2</div><div class="step-title">${t('s2')}</div></div>
      <div class="formula-block"><span class="comment">${t('cArch')} ${d.isMoE?'active':'total'} = ${d.activeB}B)</span>
layers ≈ ${d.arch.nLayers}, hidden ≈ ${fmtN(d.arch.hiddenDim)}, GQA ${d.gqa}×

<span class="comment">${t('cKvTok')}</span>
kv/tok = 2 × ${d.arch.nLayers} × ${fmtN(Math.round(d.arch.hiddenDim/d.gqa))} × 1B = <span class="highlight">${(d.kvBpT/1024).toFixed(1)} KB</span>

<span class="comment">${t('cKvUser')} ${fmtN(d.avgCtx)})</span>
kv/user = ${(d.kvBpT/1024).toFixed(1)} KB × ${fmtN(d.avgCtx)} = <span class="highlight">${(d.kvPerUser/1e6).toFixed(1)} MB</span>

max_batch = ${d.kvBudgetGB.toFixed(0)} GB / ${(d.kvPerUser/1e6).toFixed(1)} MB = <span class="result">${fmtN(d.maxBatch)}</span></div>
    </div>

    <div class="result-step">
      <div class="step-header"><div class="step-num" style="background:${bC};color:var(--bg)">3</div><div class="step-title">${t('s3')} — <span style="color:${bC}">${bL}</span></div></div>
      <div class="formula-block"><span class="comment">${t('cCluster')} ${d.numGpus}× B200</span>
BW    = ${d.numGpus} × 8 TB/s = <span class="highlight">${d.numGpus*8} TB/s</span>
FLOPS = ${d.numGpus} × ${fmt(B200.flops[d.quantBits])} = <span class="highlight">${fmt(d.totalFLOPS)}</span>  (FP${d.quantBits})
active_w = ${d.activeB}B × ${d.bpp} = <span class="highlight">${(d.activeBytes/1e9).toFixed(0)} GB</span>

<span class="comment">${t('cDecode')}</span>
bw_tput   = batch × BW / w = ${fmtN(d.maxBatch)} × ${d.numGpus*8}T / ${(d.activeBytes/1e9).toFixed(0)}G = <span class="${isBW?'result':'highlight'}">${fmtN(Math.round(d.bwTput))} tok/s</span>
comp_tput = FLOPS / 2×active = ${fmt(d.totalFLOPS)} / ${fmt(2*d.activeB*1e9)} = <span class="${!isBW?'result':'highlight'}">${fmtN(Math.round(d.compTput))} tok/s</span>

<span class="comment">${t('cCross')} ${d.crossBatch} → total ${d.crossBatch*d.numGpus}</span>
<span class="comment">${t('cActBatch')} ${fmtN(d.maxBatch)} ${d.maxBatch<d.crossBatch*d.numGpus?'<':'≥'} ${fmtN(d.crossBatch*d.numGpus)} → ${bL}</span>

decode  = min(${fmtN(Math.round(d.bwTput))}, ${fmtN(Math.round(d.compTput))}) × ${(d.eff*100).toFixed(0)}% = <span class="result">${fmtN(Math.round(d.decTput))} tok/s</span>
per_user = / ${fmtN(d.maxBatch)} = <span class="result">${d.perUser.toFixed(1)} tok/s</span>

<span class="comment">${t('cPrefill')}</span>
prefill = ${fmtN(Math.round(d.compTput))} × ${(d.eff*100).toFixed(0)}% = <span class="result">${fmtN(Math.round(d.pfTput))} tok/s</span></div>
    </div>

    <div class="result-step">
      <div class="step-header"><div class="step-num" style="background:var(--yellow);color:var(--bg)">4</div><div class="step-title">${t('s4')}</div></div>
      <div class="formula-block"><span class="comment">${t('cGpu')}</span>
cost = ${d.numGpus} × $${d.gpuPrice.toFixed(2)} = <span class="highlight">${fmtD(d.gpuCostHr)}/h</span>

<span class="comment">${t('cTokHr')} ${(d.util*100).toFixed(0)}%)</span>
decode/h  = ${fmtN(Math.round(d.decTput))} × 3600 × ${d.util.toFixed(2)} = <span class="highlight">${fmt(d.decHr)}</span>
prefill/h = ${fmtN(Math.round(d.pfTput))} × 3600 × ${d.util.toFixed(2)} = <span class="highlight">${fmt(d.pfHr)}</span>

output: ${fmtD(d.gpuCostHr)} / ${fmt(d.decHr)} = <span class="result">${fmtD(d.cOut)}/MTok</span>
input:  ${fmtD(d.gpuCostHr)} / ${fmt(d.pfHr)} = ${fmtD(d.cInRaw,3)}/MTok <span class="comment">× (1 − ${(d.cacheHit*100).toFixed(0)}% × 0.9) ${t('cCache')}</span> = <span class="result">${fmtD(d.cIn,3)}/MTok</span></div>
    </div>

    <div class="result-step">
      <div class="step-header"><div class="step-num" style="background:${pOrL?'var(--green)':'var(--red)'};color:var(--bg)">5</div><div class="step-title">${t('s5')}</div></div>
      <div class="formula-block">out: ${d.outTokM.toFixed(1)}M × ${fmtD(d.cOut)} = <span class="highlight">${fmtD(d.mOut)}</span>
in:  ${d.inTokM.toFixed(1)}M × ${fmtD(d.cIn,3)} = <span class="highlight">${fmtD(d.mIn)}</span>
total = <span class="result">${fmtD(d.mTotal)}</span>  vs ${fmtD(d.subPrice)}
→ <span class="${pOrL?'result':'warn'}">${pOrL?t('profit')+' +':t('loss')+' '}${fmtD(Math.abs(d.profit))}</span></div>

      <div class="mini-grid">
        <div class="mini-card"><div class="mc-val">${fmtD(d.mTotal)}</div><div class="mc-label">${t('cost')}</div></div>
        <div class="mini-card"><div class="mc-val" style="color:${pOrL?'var(--green)':'var(--red)'}">${pOrL?'+':''}${fmtD(d.profit)}</div><div class="mc-label">${pOrL?t('profit'):t('loss')}</div></div>
        <div class="mini-card"><div class="mc-val" style="color:${d.margin>=0?'var(--green)':'var(--red)'}">${d.margin.toFixed(1)}%</div><div class="mc-label">${t('margin')}</div></div>
      </div>
    </div>

    <div class="verdict-box ${pOrL?'':'loss'}">
      <div class="verdict-label">${t('verdict')}</div>
      <div class="verdict-number" style="color:${pOrL?'var(--green)':'var(--red)'}">${d.margin>=0?'+':''}${d.margin.toFixed(0)}% ${t('margin')}</div>
      <div class="verdict-sub" style="color:var(--text)">${t('cost')} ${fmtD(d.mTotal)} → ${pOrL?t('profit')+' '+fmtD(d.profit):t('loss')+' '+fmtD(-d.profit)} @ ${fmtD(d.subPrice)}/mo</div>
      <div style="margin-top:12px;font-size:.82em;color:var(--text-dim)">${d.numGpus}×B200 FP${d.quantBits} | ${d.isMoE?d.totalB+'B MoE ('+d.activeB+'B act)':d.totalB+'B dense'} | batch ${fmtN(d.maxBatch)} | ${d.perUser.toFixed(0)} tok/s/user | util ${(d.util*100).toFixed(0)}% | cache ${(d.cacheHit*100).toFixed(0)}%</div>
    </div>

    <div class="result-step" style="margin-top:24px;border-color:var(--border-hi)">
      <div class="step-header"><div class="step-num" style="background:var(--text-dim);color:var(--bg)">?</div><div class="step-title">${t('sRef')}</div></div>
      <div class="ref-grid" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;font-size:.78em;">
        ${rc('var(--accent)','B200 GPU',t('rB200'))}
        ${rc('var(--accent)',t('rGpuT'),t('rGpu'))}
        ${rc('var(--accent2)',t('rWtT'),t('rWt'))}
        ${rc('var(--accent2)',t('rKvT'),t('rKv'))}
        ${rc('var(--blue)',t('rDecT'),t('rDec')(d.crossBatch))}
        ${rc('var(--blue)',t('rPfT'),t('rPf'))}
        ${rc('var(--yellow)',t('rEffT')+' ('+Math.round(d.eff*100)+'%)',t('rEff')(d.eff))}
        ${rc('var(--yellow)',t('rUtilT')+' ('+Math.round(d.util*100)+'%)',t('rUtil')(d.util))}
        ${rc('var(--yellow)',t('rCaT')+' ('+Math.round(d.cacheHit*100)+'%)',t('rCa')(d.cacheHit))}
        ${rc('var(--green)',t('rTokT'),t('rTok'))}
        ${rc('var(--green)',t('rFmT'),t('rFm'))}
      </div>
    </div>`;
}

function update(){render(compute())}
applyLabels(); initMarks(); update();
</script>
</body>
</html>
